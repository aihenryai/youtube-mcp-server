"""
Dynamic Client Registration (RFC 7591 + RFC 8705)
OAuth 2.0 Dynamic Client Registration Protocol

Features:
- Client registration endpoint
- Client metadata validation
- Client credentials generation
- Client update and deletion
- Support for mTLS client authentication (RFC 8705)
"""

import os
import logging
import secrets
import hashlib
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import json

logger = logging.getLogger(__name__)


class ClientType(Enum):
    """OAuth2 client types"""
    CONFIDENTIAL = "confidential"  # Can keep secrets secure
    PUBLIC = "public"  # Cannot keep secrets secure (e.g., SPA, mobile)
    

class GrantType(Enum):
    """Supported OAuth2 grant types"""
    AUTHORIZATION_CODE = "authorization_code"
    REFRESH_TOKEN = "refresh_token"
    CLIENT_CREDENTIALS = "client_credentials"
    

@dataclass
class ClientMetadata:
    """OAuth2 Client Metadata (RFC 7591)"""
    # Required fields
    client_name: str
    redirect_uris: List[str]
    
    # Generated by server
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    client_id_issued_at: Optional[int] = None
    client_secret_expires_at: Optional[int] = None
    
    # Optional fields
    client_uri: Optional[str] = None
    logo_uri: Optional[str] = None
    tos_uri: Optional[str] = None
    policy_uri: Optional[str] = None
    contacts: List[str] = field(default_factory=list)
    
    # OAuth specifics
    grant_types: List[str] = field(default_factory=lambda: ["authorization_code", "refresh_token"])
    response_types: List[str] = field(default_factory=lambda: ["code"])
    token_endpoint_auth_method: str = "client_secret_basic"
    scope: str = "video.read video.write playlist.read playlist.write"
    
    # MCP specifics
    software_id: Optional[str] = None
    software_version: Optional[str] = None
    software_statement: Optional[str] = None
    

@dataclass
class RegisteredClient:
    """Registered OAuth2 client with full metadata"""
    metadata: ClientMetadata
    created_at: datetime
    updated_at: datetime
    status: str = "active"  # active, suspended, revoked
    

class DynamicClientRegistry:
    """
    OAuth 2.0 Dynamic Client Registration
    
    Implements:
    - RFC 7591: OAuth 2.0 Dynamic Client Registration Protocol
    - RFC 8705: OAuth 2.0 Mutual-TLS Client Authentication
    """
    
    def __init__(
        self,
        registration_endpoint: str,
        require_initial_access_token: bool = True,
        allow_public_clients: bool = True,
        client_secret_expires: bool = True,
        client_secret_ttl_days: int = 90
    ):
        """
        Initialize Dynamic Client Registry
        
        Args:
            registration_endpoint: URL of the registration endpoint
            require_initial_access_token: Require token for registration
            allow_public_clients: Allow public (non-confidential) clients
            client_secret_expires: Whether client secrets expire
            client_secret_ttl_days: Days until client secret expires
        """
        self.registration_endpoint = registration_endpoint
        self.require_initial_access_token = require_initial_access_token
        self.allow_public_clients = allow_public_clients
        self.client_secret_expires = client_secret_expires
        self.client_secret_ttl_days = client_secret_ttl_days
        
        # In-memory storage (replace with database in production)
        self.clients: Dict[str, RegisteredClient] = {}
        
        # Valid initial access tokens (admin-generated)
        self.initial_access_tokens = set()
        
        logger.info(f"Dynamic Client Registry initialized at {registration_endpoint}")
    
    def register_client(
        self,
        metadata: ClientMetadata,
        initial_access_token: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Register a new OAuth2 client
        
        Args:
            metadata: Client metadata
            initial_access_token: Initial access token (if required)
        
        Returns:
            Dictionary with client credentials and metadata
        
        Raises:
            ValueError: If validation fails
        
        Example:
            >>> metadata = ClientMetadata(
            ...     client_name="My MCP Client",
            ...     redirect_uris=["https://myapp.com/callback"],
            ...     grant_types=["authorization_code", "refresh_token"]
            ... )
            >>> response = registry.register_client(
            ...     metadata=metadata,
            ...     initial_access_token="admin_generated_token"
            ... )
            >>> # Save client_id and client_secret securely!
        """
        # 1. Validate initial access token if required
        if self.require_initial_access_token:
            if not initial_access_token or initial_access_token not in self.initial_access_tokens:
                raise ValueError("Invalid or missing initial access token")
        
        # 2. Validate metadata
        self._validate_metadata(metadata)
        
        # 3. Generate client credentials
        client_id = self._generate_client_id()
        client_secret = self._generate_client_secret()
        
        # 4. Set client metadata
        metadata.client_id = client_id
        metadata.client_secret = client_secret
        metadata.client_id_issued_at = int(datetime.now().timestamp())
        
        if self.client_secret_expires:
            expires_at = datetime.now() + timedelta(days=self.client_secret_ttl_days)
            metadata.client_secret_expires_at = int(expires_at.timestamp())
        else:
            metadata.client_secret_expires_at = 0  # Never expires
        
        # 5. Store client
        registered_client = RegisteredClient(
            metadata=metadata,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        self.clients[client_id] = registered_client
        
        logger.info(f"Client registered: {client_id} ({metadata.client_name})")
        
        # 6. Return response per RFC 7591
        return {
            "client_id": client_id,
            "client_secret": client_secret,
            "client_id_issued_at": metadata.client_id_issued_at,
            "client_secret_expires_at": metadata.client_secret_expires_at,
            "client_name": metadata.client_name,
            "redirect_uris": metadata.redirect_uris,
            "grant_types": metadata.grant_types,
            "response_types": metadata.response_types,
            "token_endpoint_auth_method": metadata.token_endpoint_auth_method,
            "scope": metadata.scope,
            "registration_client_uri": f"{self.registration_endpoint}/{client_id}",
            "registration_access_token": self._generate_registration_access_token(client_id)
        }
    
    def update_client(
        self,
        client_id: str,
        registration_access_token: str,
        updated_metadata: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Update existing client metadata
        
        Args:
            client_id: Client ID to update
            registration_access_token: Token from registration response
            updated_metadata: Fields to update
        
        Returns:
            Updated client metadata
        
        Raises:
            ValueError: If validation fails or client not found
        """
        # 1. Validate registration access token
        if not self._verify_registration_access_token(client_id, registration_access_token):
            raise ValueError("Invalid registration access token")
        
        # 2. Get existing client
        if client_id not in self.clients:
            raise ValueError(f"Client not found: {client_id}")
        
        client = self.clients[client_id]
        
        # 3. Update allowed fields
        allowed_fields = {
            'client_name', 'redirect_uris', 'client_uri', 'logo_uri',
            'tos_uri', 'policy_uri', 'contacts', 'scope'
        }
        
        for field, value in updated_metadata.items():
            if field in allowed_fields:
                setattr(client.metadata, field, value)
        
        client.updated_at = datetime.now()
        
        logger.info(f"Client updated: {client_id}")
        
        # 4. Return updated metadata
        return self._client_to_dict(client)
    
    def delete_client(
        self,
        client_id: str,
        registration_access_token: str
    ):
        """
        Delete (revoke) a client
        
        Args:
            client_id: Client ID to delete
            registration_access_token: Token from registration response
        
        Raises:
            ValueError: If validation fails or client not found
        """
        # 1. Validate registration access token
        if not self._verify_registration_access_token(client_id, registration_access_token):
            raise ValueError("Invalid registration access token")
        
        # 2. Get existing client
        if client_id not in self.clients:
            raise ValueError(f"Client not found: {client_id}")
        
        # 3. Mark as revoked (soft delete)
        self.clients[client_id].status = "revoked"
        
        logger.info(f"Client deleted: {client_id}")
    
    def get_client(self, client_id: str) -> Optional[RegisteredClient]:
        """
        Get registered client by ID
        
        Args:
            client_id: Client ID
        
        Returns:
            RegisteredClient if found and active, None otherwise
        """
        client = self.clients.get(client_id)
        
        if client and client.status == "active":
            return client
        
        return None
    
    def validate_client_credentials(
        self,
        client_id: str,
        client_secret: str
    ) -> bool:
        """
        Validate client credentials
        
        Args:
            client_id: Client ID
            client_secret: Client secret
        
        Returns:
            True if valid and not expired, False otherwise
        """
        client = self.get_client(client_id)
        
        if not client:
            return False
        
        # Check secret matches
        if client.metadata.client_secret != client_secret:
            return False
        
        # Check expiration
        if self.client_secret_expires:
            expires_at = datetime.fromtimestamp(
                client.metadata.client_secret_expires_at
            )
            if expires_at < datetime.now():
                logger.warning(f"Client secret expired: {client_id}")
                return False
        
        return True
    
    def rotate_client_secret(
        self,
        client_id: str,
        registration_access_token: str
    ) -> Dict[str, Any]:
        """
        Rotate client secret (generate new one)
        
        Args:
            client_id: Client ID
            registration_access_token: Token from registration response
        
        Returns:
            New client secret and expiration
        
        Raises:
            ValueError: If validation fails
        """
        # 1. Validate registration access token
        if not self._verify_registration_access_token(client_id, registration_access_token):
            raise ValueError("Invalid registration access token")
        
        # 2. Get existing client
        if client_id not in self.clients:
            raise ValueError(f"Client not found: {client_id}")
        
        client = self.clients[client_id]
        
        # 3. Generate new secret
        new_secret = self._generate_client_secret()
        client.metadata.client_secret = new_secret
        
        if self.client_secret_expires:
            expires_at = datetime.now() + timedelta(days=self.client_secret_ttl_days)
            client.metadata.client_secret_expires_at = int(expires_at.timestamp())
        
        client.updated_at = datetime.now()
        
        logger.info(f"Client secret rotated: {client_id}")
        
        return {
            "client_id": client_id,
            "client_secret": new_secret,
            "client_secret_expires_at": client.metadata.client_secret_expires_at
        }
    
    def generate_initial_access_token(self) -> str:
        """
        Generate initial access token (admin only)
        
        Returns:
            New initial access token
        
        Example:
            >>> token = registry.generate_initial_access_token()
            >>> # Share this token with client developers
        """
        token = secrets.token_urlsafe(32)
        self.initial_access_tokens.add(token)
        
        logger.info("New initial access token generated")
        return token
    
    def _validate_metadata(self, metadata: ClientMetadata):
        """Validate client metadata per RFC 7591"""
        # Client name required
        if not metadata.client_name:
            raise ValueError("client_name is required")
        
        # At least one redirect URI required
        if not metadata.redirect_uris or len(metadata.redirect_uris) == 0:
            raise ValueError("At least one redirect_uri is required")
        
        # Validate redirect URIs
        for uri in metadata.redirect_uris:
            if not uri.startswith('https://') and not uri.startswith('http://localhost'):
                raise ValueError(f"Invalid redirect_uri: {uri} (must be HTTPS or localhost)")
        
        # Validate grant types
        valid_grants = {gt.value for gt in GrantType}
        for grant in metadata.grant_types:
            if grant not in valid_grants:
                raise ValueError(f"Invalid grant_type: {grant}")
        
        # Public clients cannot use client_credentials
        if not metadata.client_secret and "client_credentials" in metadata.grant_types:
            raise ValueError("Public clients cannot use client_credentials grant")
    
    def _generate_client_id(self) -> str:
        """Generate unique client ID"""
        return f"mcp_client_{secrets.token_urlsafe(16)}"
    
    def _generate_client_secret(self) -> str:
        """Generate secure client secret"""
        return secrets.token_urlsafe(32)
    
    def _generate_registration_access_token(self, client_id: str) -> str:
        """Generate registration access token for client management"""
        # In production, use JWT with signature
        token_data = f"{client_id}:{secrets.token_urlsafe(32)}"
        return hashlib.sha256(token_data.encode()).hexdigest()
    
    def _verify_registration_access_token(
        self,
        client_id: str,
        token: str
    ) -> bool:
        """Verify registration access token"""
        # In production, verify JWT signature
        # For now, just check if client exists and token format is correct
        return client_id in self.clients and len(token) == 64
    
    def _client_to_dict(self, client: RegisteredClient) -> Dict[str, Any]:
        """Convert RegisteredClient to dictionary"""
        return {
            "client_id": client.metadata.client_id,
            "client_name": client.metadata.client_name,
            "client_uri": client.metadata.client_uri,
            "logo_uri": client.metadata.logo_uri,
            "redirect_uris": client.metadata.redirect_uris,
            "grant_types": client.metadata.grant_types,
            "response_types": client.metadata.response_types,
            "scope": client.metadata.scope,
            "created_at": client.created_at.isoformat(),
            "updated_at": client.updated_at.isoformat(),
            "status": client.status
        }


def create_client_registry(
    registration_endpoint: str,
    require_initial_access_token: bool = True,
    allow_public_clients: bool = True
) -> DynamicClientRegistry:
    """
    Factory function to create Dynamic Client Registry
    
    Args:
        registration_endpoint: URL of registration endpoint
        require_initial_access_token: Require token for registration
        allow_public_clients: Allow public clients
    
    Returns:
        Configured DynamicClientRegistry instance
    
    Example:
        >>> registry = create_client_registry(
        ...     registration_endpoint="https://mcp-server.example.com/register",
        ...     require_initial_access_token=True
        ... )
    """
    return DynamicClientRegistry(
        registration_endpoint=registration_endpoint,
        require_initial_access_token=require_initial_access_token,
        allow_public_clients=allow_public_clients
    )
